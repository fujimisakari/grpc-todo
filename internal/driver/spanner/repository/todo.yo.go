// Code generated by yo. DO NOT EDIT.
// Package repository contains the types.
package repository

import (
	"fmt"
	"time"

	"cloud.google.com/go/spanner"

	"github.com/fujimisakari/grpc-todo/internal/domain"
)

// TodoDto represents a row from 'Todos'.
type TodoDto struct {
	ID          string             `spanner:"Id" json:"Id"`                   // Id
	Title       string             `spanner:"Title" json:"Title"`             // Title
	Description spanner.NullString `spanner:"Description" json:"Description"` // Description
	Priority    int64              `spanner:"Priority" json:"Priority"`       // Priority
	Completed   bool               `spanner:"Completed" json:"Completed"`     // Completed
	DueTime     spanner.NullTime   `spanner:"DueTime" json:"DueTime"`         // DueTime
	CreatedAt   time.Time          `spanner:"CreatedAt" json:"CreatedAt"`     // CreatedAt
	UpdatedAt   spanner.NullTime   `spanner:"UpdatedAt" json:"UpdatedAt"`     // UpdatedAt
}

func (t *TodoDto) ToEntity() *domain.Todo {
	return &domain.Todo{
		ID:          t.ID,
		Title:       t.Title,
		Description: t.Description.String(),
		Priority:    domain.Priority(t.Priority),
		Completed:   t.Completed,
		DueTime:     t.DueTime.Time.In(time.FixedZone("JST", 9*60*60)),
		CreatedAt:   t.CreatedAt.In(time.FixedZone("JST", 9*60*60)),
		UpdatedAt:   t.UpdatedAt.Time.In(time.FixedZone("JST", 9*60*60)),
	}
}

func (t *TodoDto) primaryKeys() []string {
	return []string{
		"Id",
	}
}

func (t *TodoDto) writableColumns() []string {
	return []string{
		"Id",
		"Title",
		"Description",
		"Priority",
		"Completed",
		"DueTime",
		"CreatedAt",
		"UpdatedAt",
	}
}

func (t *TodoDto) columnsToPtrs(cols []string, customPtrs map[string]interface{}) ([]interface{}, error) {
	ret := make([]interface{}, 0, len(cols))
	for _, col := range cols {
		if val, ok := customPtrs[col]; ok {
			ret = append(ret, val)
			continue
		}

		switch col {
		case "Id":
			ret = append(ret, &t.ID)
		case "Title":
			ret = append(ret, &t.Title)
		case "Description":
			ret = append(ret, &t.Description)
		case "Priority":
			ret = append(ret, &t.Priority)
		case "Completed":
			ret = append(ret, &t.Completed)
		case "DueTime":
			ret = append(ret, &t.DueTime)
		case "CreatedAt":
			ret = append(ret, &t.CreatedAt)
		case "UpdatedAt":
			ret = append(ret, &t.UpdatedAt)
		default:
			return nil, fmt.Errorf("unknown column: %s", col)
		}
	}
	return ret, nil
}

func (t *TodoDto) columnsToValues(cols []string) ([]interface{}, error) {
	ret := make([]interface{}, 0, len(cols))
	for _, col := range cols {
		switch col {
		case "Id":
			ret = append(ret, t.ID)
		case "Title":
			ret = append(ret, t.Title)
		case "Description":
			ret = append(ret, t.Description)
		case "Priority":
			ret = append(ret, int64(t.Priority))
		case "Completed":
			ret = append(ret, t.Completed)
		case "DueTime":
			ret = append(ret, t.DueTime)
		case "CreatedAt":
			ret = append(ret, t.CreatedAt)
		case "UpdatedAt":
			ret = append(ret, t.UpdatedAt)
		default:
			return nil, fmt.Errorf("unknown column: %s", col)
		}
	}

	return ret, nil
}

// Insert returns a Mutation to insert a row into a table. If the row already
// exists, the write or transaction fails.
func (t *TodoDto) Insert() *spanner.Mutation {
	values, _ := t.columnsToValues(t.writableColumns())
	return spanner.Insert("Todos", t.writableColumns(), values)
}

// Update returns a Mutation to update a row in a table. If the row does not
// already exist, the write or transaction fails.
func (t *TodoDto) Update() *spanner.Mutation {
	values, _ := t.columnsToValues(t.writableColumns())
	return spanner.Update("Todos", t.writableColumns(), values)
}

// Delete deletes the Todo from the database.
func (t *TodoDto) Delete() *spanner.Mutation {
	values, _ := t.columnsToValues(t.primaryKeys())
	return spanner.Delete("Todos", spanner.Key(values))
}
